#!/usr/bin/env python3
# coding: utf-8
# Copyright 2025 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
from swft.core import Tensor, Scalar, name_tensor, can_fit_memory
from .compute import vadds, vdiv, vexp, vmuls, vsubs, vector_dup, concat
from .move import move_scalar_to_ub, move_to_ub
from .slicedata import slice_to_ub
from swft.utils import TYPE_SIZE


@name_tensor
def tanh(src):
    if not isinstance(src, Tensor):
        raise TypeError("For tanh, the input must be tensor")
    if src.dtype != "FP16" and src.dtype != "FP32":
        raise TypeError("For tanh, the input dtype must be FP16 or FP32!")
    out1 = vsubs(vexp(vmuls(src, 2)), 1)
    out2 = vadds(vexp(vmuls(src, 2)), 1)
    return vdiv(out1, out2)


def arange_naive(num, dtype="INT32"):
    if not isinstance(num, int):
        raise TypeError("For arange, num must be int")
    if dtype != "INT32" and dtype != "INT16":
        raise TypeError("For arange, the target dtype must be INT16 or INT32!")
    zero = Scalar(dtype, 0)
    ub_range = vector_dup(zero, [num], False)
    for i in range(num):
        ub_range = move_scalar_to_ub(i, ub_range, i)
    return ub_range


def arange_simd(start, stop, step, simd_width, values):
    size = int(np.ceil((stop - start) / step))
    vec_loops = size // simd_width
    remainder = size % simd_width
    arange_lst = []
    if step == 1:
        for i in range(vec_loops):
            arange_lst.append(values)
            values = vadds(values, simd_width)

        if remainder > 0:
            values = slice_to_ub(values, [0], [remainder])
            arange_lst.append(values)
    else:
        values = vmuls(values, step)
        for i in range(vec_loops):
            arange_lst.append(values)
            values = vadds(values, simd_width * step)

        if remainder > 0:
            values = slice_to_ub(values, [0], [remainder])
            arange_lst.append(values)
    return concat(arange_lst, 0)


@name_tensor
def arange(start, stop=None, step=1, dtype="INT32"):
    if stop is None:
        stop = start
        start = 0
    if not isinstance(start, int):
        raise TypeError("For arange, start must be int")
    if stop is not None and (not isinstance(stop, int)):
        raise TypeError("For arange, stop must be int")
    if not isinstance(step, int):
        raise TypeError("For arange, step must be int")
    if step == 0:
        raise ValueError("step cannot be zero")
    if (start >= stop and step > 0) or (start <= stop and step < 0):
        raise ValueError("invalid start/stop/step for arange")
    size = int(np.ceil((stop - start) / step))
    dtype_size = TYPE_SIZE[dtype] // 8
    if not can_fit_memory(size * dtype_size * 2, "UB"):
        raise ValueError(
            "For arange, the number of element cannot fit UB memory!")
    if size < 32 / dtype_size:
        values = arange_naive(size, dtype=dtype)
        if start != 0:
            values = vadds(values, start)
        if step != 1:
            values = vmuls(values, step)
        return values

    if size >= 32 // dtype_size and size < 256 // dtype_size:
        values_16 = arange_naive(32 // dtype_size, dtype=dtype)
        return arange_simd(start, stop, step, 32 // dtype_size, values_16)

    values_16 = arange_naive(32 // dtype_size, dtype=dtype)
    values_128 = arange_simd(0, 256 // dtype_size, 1, 32 // dtype_size, values_16)
    return arange_simd(start, stop, step, 256 // dtype_size, values_128)

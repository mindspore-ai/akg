你是一个专业的高性能计算代码生成专家，专门负责将 AUL (AI Unity Language) 代码转换为高效的 SWFT (Ascend后端编译器) 代码。要求仅用SWFT支持的API完成代码翻译。

1. 原始任务描述：

{{ task_desc }}


2. AUL代码：

{{ aul_code }}


3. SWFT支持的API
- 装饰器
@sub_kernel(core_num=...), core_num表示核数

- Host侧定义, Tensor(mem_type, dtype=None, size=None, format=None, multi_core=False)
  - mem_type: "GM"
  - dtype: "FP16", "FP32", "INT32", "INT8"等，从原始任务以及AUL代码的输入输出分析
  - format: "ND", "NZ", "NCHW", "NHWC", "NC0HWC1", "FM", "FT"
  - size: [s0, s1, s2...]，需要明确给出size大小，从原始任务或者AUL的输入输出分析
  - multi_core: 永远为False，不需要考虑

- 当前任务SWFT支持的API列表(MarkDown格式)

{{ supported_api }}


4. AUL到SWFT转换指南
  - AUL中的`U.vbinary_op, U.vunary_op, U.vreduce_op, U.matmul_op, U.vectorscalar_op`等转换为SWFT的计算API
  - AUL中的`U.data_copy`需要转换为SWFT的数据移动API
  - AUL中的`U.get_core_idx()`转换为SWFT的get_block_idx()
  - AUL中的`U.Pipelined`循环结构需要转换为for循环
  - AUL中的`U.Tile`和`U.FilledTile`不需要翻译，直接删除，直接删除，直接删除


5. 生成的SWFT代码模板如下：
```
from swft.core import *    #必须导入
from swft.api import *     #必须导入
import os                  #必须导入
OP_NAME = "{{ op_name }}"

@sub_kernel(core_num=...)
def {{ op_name }}_impl(input0, ..., output0):
    ...

def {{ op_name }}_swft(device_id=0):
    set_context("310P")
    input0 = Tensor("GM", ...)  #必须命名为input+索引号
    output0 = Tensor("GM", ...) #必须命名为output+索引号
    ...

    compile_func({{ op_name }}_impl, globals())(input0, output0)
    current_dir = os.path.dirname(__file__)
    cce_path = os.path.join(current_dir, f"{OP_NAME}", f"{OP_NAME}.cce")
    compile_kernel(cce_path, OP_NAME)
    exec_kernel(OP_NAME, locals(), inputs=['input0'], outputs=['output0'], device_id=device_id)

def {{ op_name }}_swft_{{framework}}(device_id=0):
    {{ op_name }}_swft(device_id)
```


6. SWFT样例代码参考：

- 推荐样例代码

{{ swft_sample_code }}

- 错误样例代码

{{ error_sample }}


**强制要求1. API使用**
- 所有API使用必须严格遵守SWFT支持的API列表，请反复校验确保不会有遗漏。
- 如果存在SWFT不支持的API，可以通过组合其支持的API实现类似功能。

**推荐1. API使用**
- 如果能在示例代码中找到相似的API使用，请直接使用示例代码中的API使用方式。

**重要提示**
- 如果AUL运算中输入Tensor仅包含一个标量，需要的指令包含 move_to_scalar/Scalar + 向量标量指令 或者 vbrcb/vector_dup + 向量向量指令
- 如果输入Tensor是标量，必须表示为常量，不能以入参的形式给出
- 输入输出命名必须为input/output + 索引，如input0, output1等

- for循环中使用range中的参数不要使用Scalar对象，只能是integer
- 不要重复定义变量，变量只能被赋值一次
- 当使用vector_dup时，需要将factor转换成Scalar
- 如果双目运算允许Tensor和Scalar进行运算，则删去vector_dup操作
- slice_to_ub不要出现dst参数
- slice_to_ub和insert_to_gm要求入参begin和slicesize的数据维度必须和输入Tensor的数据维度一致
- move_to_scalar入参的Tensor的shape必须为[1]


**请尽可能使用中文进行思考分析**

**请按照以下格式输出你的结果，仅返回json格式，不要包含任何解释或额外内容：**

{{ format_instructions }}

**请按照以下格式输出你的结果，仅返回json格式，不要包含任何解释或额外内容：**

{{ format_instructions }}

unchanged:
--- isl-0.22/include/isl/options.h	2021-10-08 14:34:24.500105000 +0800
+++ isl/include/isl/options.h	2021-10-08 23:20:41.245515766 +0800
@@ -49,6 +49,13 @@ int isl_options_get_coalesce_bounded_wra
 isl_stat isl_options_set_coalesce_preserve_locals(isl_ctx *ctx, int val);
 int isl_options_get_coalesce_preserve_locals(isl_ctx *ctx);
 
+/* ====================== AKG influence patch -- start ====================== */
+isl_stat isl_options_set_akg_print_debug(isl_ctx *ctx, int val);
+int isl_options_get_akg_print_debug(isl_ctx *ctx);
+isl_stat isl_options_set_akg_influence_scheduler(isl_ctx *ctx, int val);
+int isl_options_get_akg_influence_scheduler(isl_ctx *ctx);
+/* ======================= AKG influence patch -- end ======================= */
+
 #if defined(__cplusplus)
 }
 #endif
diff -u isl/include/isl/schedule.h isl/include/isl/schedule.h
--- isl/include/isl/schedule.h	2021-10-08 23:20:41.249515618 +0800
+++ isl/include/isl/schedule.h	2021-12-28 09:51:36.316000000 +0800
@@ -9,7 +9,7 @@
 #include <isl/set_type.h>
 #include <isl/list.h>
 #include <isl/printer_type.h>
-
+#include <isl/vec.h>
 #if defined(__cplusplus)
 extern "C" {
 #endif
@@ -209,6 +209,122 @@
 void isl_schedule_dump(__isl_keep isl_schedule *schedule);
 __isl_give char *isl_schedule_to_str(__isl_keep isl_schedule *schedule);
 
+/* ====================== AKG influence patch -- start ====================== */
+
+/* --- Exports --- */
+
+/* export hidden types */
+struct isl_sched_node;
+typedef struct isl_sched_node isl_sched_node;
+struct isl_sched_edge;
+typedef struct isl_sched_edge isl_sched_edge;
+struct isl_sched_graph;
+typedef struct isl_sched_graph isl_sched_graph;
+
+/* --- New types --- */
+
+enum isl_influence_coeff_type {
+	isl_cst,
+	isl_param,
+	isl_var
+};
+typedef enum isl_influence_coeff_type isl_influence_coeff_type;
+
+struct isl_influence_equal {
+	char *statement1;
+	char *statement2;
+	int sched_dim;
+	int sched_dim1;
+	int sched_dim2;
+	isl_influence_coeff_type type;
+	int coef_dim1;
+	int coef_dim2;
+	int scanned;
+};
+typedef struct isl_influence_equal isl_influence_equal;
+
+struct isl_influence_equal_list {
+	int size;
+	int mem;
+	struct isl_influence_equal *data;
+};
+typedef struct isl_influence_equal_list isl_influence_equal_list;
+
+struct isl_influence {
+	char *statement_name;
+	isl_influence_coeff_type type;
+	int sched_dim;
+	int coef_dim;
+	int val;
+	int scanned;
+};
+typedef struct isl_influence isl_influence;
+
+struct isl_influence_list {
+	int size;
+	int mem;
+	struct isl_influence *data;
+};
+typedef struct isl_influence_list isl_influence_list;
+
+struct isl_influence_sol {
+	int size;
+	int mem;
+	int *data;
+};
+typedef struct isl_influence_sol isl_influence_sol;
+
+struct isl_influence_sol_list {
+	int size;
+	int mem;
+	isl_influence_sol *data;
+};
+typedef struct isl_influence_sol_list isl_influence_sol_list;
+
+/* isl_sched_node functions */
+int isl_sched_node_par_coef_offset(struct isl_sched_node *node);
+int isl_sched_node_cst_coef_offset(struct isl_sched_node *node);
+__isl_give isl_map *isl_sched_node_extract_schedule(struct isl_sched_node *node);
+
+/* isl vec functions */
+int isl_inf_vec_get_size( isl_vec* vec);
+/* export isl_sched_edge functions */
+/* export isl_sched_graph functions */
+isl_stat isl_sched_graph_init(struct isl_sched_graph *graph,
+	__isl_keep isl_schedule_constraints *sc);
+void isl_sched_graph_free(isl_ctx *ctx, struct isl_sched_graph *graph);
+__isl_give isl_schedule_node *isl_schedule_node_compute_schedule(isl_schedule_node *node,
+	struct isl_sched_graph *graph);
+
+/* --- New functions --- */
+
+/* isl_sched_node functions */
+int isl_sched_node_get_nparam(const struct isl_sched_node *node);
+int isl_sched_node_get_nvar(const struct isl_sched_node *node);
+
+/* isl_vec functions */
+int  isl_influence_int_eq(isl_vec* v, int pos1, int pos2);
+isl_val*  isl_influence_vec_get_elem(isl_vec*, int pos);
+/* isl_sched_graph functions */
+struct isl_sched_node* isl_sched_graph_get_node(struct isl_sched_graph *graph, int i);
+
+
+/* --- AKG influence --- */
+extern int isl_influence_enabled;
+isl_basic_set *isl_influence_set_coef(isl_ctx *ctx, struct isl_sched_graph *graph, isl_basic_set *bset);
+isl_basic_set *isl_influence_set_equal(isl_ctx *ctx, struct isl_sched_graph *graph, isl_basic_set *bset);
+int isl_influence_maxvar(struct isl_sched_graph *graph);
+struct isl_sched_graph *isl_influence_sol_add_elem(isl_vec *sol, struct isl_sched_graph *graph);
+int isl_influence_sol_get_elem(int sched, int pos, struct isl_sched_graph *graph);
+struct isl_sched_graph *isl_influence_sol_list_free(struct isl_sched_graph *graph);
+
+void *isl_influence_list_free(isl_influence_list *inf_list);
+void *isl_influence_equal_list_free(isl_influence_equal_list *inf_equal_list);
+
+__isl_give isl_schedule *akg_isl_schedule_constraints_compute_schedule_influence(
+	__isl_take isl_schedule_constraints *sc, isl_influence_list *inf_coef, isl_influence_equal_list *inf_equal);
+/* ======================= AKG influence patch -- end ======================= */
+
 #if defined(__cplusplus)
 }
 #endif
unchanged:
--- isl-0.22/isl_options.c	2021-10-08 14:48:47.000000000 +0800
+++ isl/isl_options.c	2021-10-08 23:20:41.249515618 +0800
@@ -228,6 +228,12 @@ ISL_ARG_BOOL(struct isl_options, print_s
 	"print statistics for every isl_ctx")
 ISL_ARG_ULONG(struct isl_options, max_operations, 0,
 	"max-operations", 0, "default number of maximal operations per isl_ctx")
+/* ====================== AKG influence patch -- start ====================== */
+ISL_ARG_BOOL(struct isl_options, akg_print_debug, 0, "print-debug", 0,
+	"print debug info")
+ISL_ARG_BOOL(struct isl_options, akg_influence_scheduler, 0, "influence-schedule", 0,
+	"update scheduler coefficients")
+/* ======================= AKG influence patch -- end ======================= */
 ISL_ARG_VERSION(print_version)
 ISL_ARGS_END
 
@@ -402,3 +408,14 @@ ISL_CTX_SET_BOOL_DEF(isl_options, struct
 	ast_build_allow_or)
 ISL_CTX_GET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
 	ast_build_allow_or)
+
+/* ====================== AKG influence patch -- start ====================== */
+ISL_CTX_SET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
+	akg_print_debug)
+ISL_CTX_GET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
+	akg_print_debug)
+ISL_CTX_SET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
+	akg_influence_scheduler)
+ISL_CTX_GET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
+	akg_influence_scheduler)
+/* ======================= AKG influence patch -- end ======================= */
unchanged:
--- isl-0.22/isl_options_private.h	2021-10-08 14:40:05.232984000 +0800
+++ isl/isl_options_private.h	2021-10-08 23:20:41.249515618 +0800
@@ -71,6 +71,10 @@ struct isl_options {
 
 	int			print_stats;
 	unsigned long		max_operations;
+/* ====================== AKG influence patch -- start ====================== */
+	int			akg_print_debug;
+	int			akg_influence_scheduler;
+/* ======================= AKG influence patch -- end ======================= */
 };
 
 #endif
diff -u isl/isl_scheduler.c isl/isl_scheduler.c
--- isl/isl_scheduler.c	2021-10-09 10:14:06.401347938 +0800
+++ isl/isl_scheduler.c	2021-12-28 09:51:17.288000000 +0800
@@ -50,6 +50,15 @@
  */
 
 
+/* ====================== AKG influence patch -- start ====================== */
+static const char *inf_types_str[] = {
+	[isl_cst] = "isl_cst",
+	[isl_param] = "isl_param",
+	[isl_var] = "isl_var",
+};
+int isl_influence_enabled = { 0 };
+/* ======================= AKG influence patch -- end ======================= */
+
 /* Internal information about a node that is used during the construction
  * of a schedule.
  * space represents the original space in which the domain lives;
@@ -303,6 +312,12 @@
 	return is_condition(edge) || is_conditional_validity(edge);
 }
 
+/* ====================== AKG influence patch -- start ====================== */
+struct isl_influence_list;
+struct isl_influence_equal_list;
+struct isl_influence_sol_list;
+/* ======================= AKG influence patch -- end ======================= */
+
 /* Internal information about the dependence graph used during
  * the construction of the schedule.
  *
@@ -395,6 +410,11 @@
 	int weak;
 
 	int max_weight;
+/* ====================== AKG influence patch -- start ====================== */
+	struct isl_influence_list *inf_list;
+	struct isl_influence_equal_list *inf_equal_list;
+	struct isl_influence_sol_list* inf_sol_list;
+/* ======================= AKG influence patch -- end ======================= */
 };
 
 /* Initialize node_table based on the list of nodes.
@@ -757,6 +777,8 @@
 		isl_hash_table_free(ctx, graph->edge_table[i]);
 	isl_hash_table_free(ctx, graph->node_table);
 	isl_basic_set_free(graph->lp);
+	if(isl_influence_enabled)
+		graph=isl_influence_sol_list_free(graph);
 }
 
 /* For each "set" on which this function is called, increment
@@ -3233,6 +3255,7 @@
  * In particular, the non-triviality region enforces that at least
  * one of the linear combinations in the rows of node->indep is non-zero.
  */
+
 static __isl_give isl_vec *solve_lp(isl_ctx *ctx, struct isl_sched_graph *graph)
 {
 	int i;
@@ -3251,8 +3274,49 @@
 		graph->region[i].trivial = trivial;
 	}
 	lp = isl_basic_set_copy(graph->lp);
+/* ====================== AKG influence patch -- start ====================== */
+	isl_basic_set *lp_backup;
+	isl_basic_set *lp_backup_inf;
+	const int akg_influence = isl_options_get_akg_influence_scheduler(ctx);
+	const int akg_debug = isl_options_get_akg_print_debug(ctx);
+	if (akg_influence) {
+		lp_backup = isl_basic_set_copy(graph->lp);
+		lp = isl_influence_set_coef(ctx, graph, lp);
+		lp = isl_influence_set_equal(ctx, graph, lp);
+		lp_backup_inf = isl_basic_set_copy(lp);
+	}
+/* ======================= AKG influence patch -- end ======================= */
 	sol = isl_tab_basic_set_non_trivial_lexmin(lp, 2, graph->n,
 				       graph->region, &check_conflict, graph);
+/* ====================== AKG influence patch -- start ====================== */
+	if (akg_influence) {
+		if(sol->size == 0) {
+			if (akg_debug >= 1)  fprintf(stderr, "\ninfluence schedule did not find solution, relax region and try again::\n");
+			isl_vec_free(sol);
+
+			for(int i=0; i< graph->n;i++) {
+				isl_mat_free(graph->region[i].trivial);
+				graph->region[i].trivial = isl_mat_zero(ctx,0,0);
+			}
+
+			sol = isl_tab_basic_set_non_trivial_lexmin(lp_backup_inf, 2, graph->n, graph->region, &check_conflict, graph);
+
+			if (sol->size == 0) {
+				if (akg_debug >= 1)  fprintf(stderr, "\ninfluence schedule did not find solution, another try with use_coincidence=0:\n");
+			} else {
+				isl_basic_set_free(lp_backup);
+			}
+		} else {
+			isl_basic_set_free(lp_backup);
+			isl_basic_set_free(lp_backup_inf);
+		}
+	}
+
+	if (!sol->size) {
+		if (akg_debug >= 1)
+			fprintf(stderr, "solve_lp did not find solution for dimension: %d\n",graph->n_row);
+	}
+/* ======================= AKG influence patch -- end ======================= */
 	for (i = 0; i < graph->n; ++i)
 		isl_mat_free(graph->region[i].trivial);
 	return sol;
@@ -3315,10 +3379,15 @@
 	if (sol->size == 0)
 		isl_die(sol->ctx, isl_error_internal,
 			"no solution found", goto error);
-	if (graph->n_total_row >= graph->max_row)
+/* ====================== AKG influence patch -- start ====================== */
+	isl_ctx* const ctx = isl_vec_get_ctx(sol);
+	const int akg_influence = isl_options_get_akg_influence_scheduler(ctx);
+	const int akg_debug = isl_options_get_akg_print_debug(ctx);
+
+	if (!akg_influence && graph->n_total_row >= graph->max_row)
 		isl_die(sol->ctx, isl_error_internal,
 			"too many schedule rows", goto error);
-
+/* ======================= AKG influence patch -- end ======================= */
 	for (i = 0; i < graph->n; ++i) {
 		struct isl_sched_node *node = &graph->node[i];
 		int pos;
@@ -3351,6 +3420,13 @@
 
 	graph->n_row++;
 	graph->n_total_row++;
+/* ====================== AKG influence patch -- start ====================== */
+	if (akg_influence && graph->n_row  == graph->maxvar) {
+		if(graph->n_row  < isl_influence_maxvar(graph)) {
+			graph->maxvar++;
+		}
+	}
+/* ======================= AKG influence patch -- end ======================= */
 
 	return 0;
 error:
@@ -3979,6 +4055,10 @@
 	sub->max_row = graph->max_row;
 	sub->n_total_row = graph->n_total_row;
 	sub->band_start = graph->band_start;
+/* ====================== AKG influence patch -- start ====================== */
+	sub->inf_list = graph->inf_list;
+	sub->inf_equal_list = graph->inf_equal_list;
+/* ======================= AKG influence patch -- end ======================= */
 
 	return isl_stat_ok;
 }
@@ -4008,6 +4088,11 @@
 {
 	struct isl_sched_graph split = { 0 };
 
+/* ====================== AKG influence patch -- start ====================== */
+	const int akg_influence = isl_options_get_akg_influence_scheduler(ctx);
+	const int akg_debug = isl_options_get_akg_print_debug(ctx);
+/* ======================= AKG influence patch -- end ======================= */
+
 	if (extract_sub_graph(ctx, graph, node_pred, edge_pred, data,
 				&split) < 0)
 		goto error;
@@ -5407,6 +5492,25 @@
 		return NULL;
 
 	lp = isl_basic_set_copy(graph->lp);
+/* ====================== AKG influence patch -- start ====================== */
+	const int akg_influence = isl_options_get_akg_influence_scheduler(ctx);
+	const int akg_debug = isl_options_get_akg_print_debug(ctx);
+	if (akg_influence) {
+		isl_basic_set *lp_backup = isl_basic_set_copy(graph->lp);
+		lp = isl_influence_set_coef(ctx, graph, lp);
+		lp = isl_influence_set_equal(ctx, graph, lp);
+		isl_vec *sol = non_neg_lexmin(graph, lp, n_edge, want_integral);
+		if (sol->size == 0) {
+			if (akg_debug >= 1) {
+				fprintf(stderr, "\ncarry_lp hack failed, restoring previous lp problem\n");
+			}
+			sol = non_neg_lexmin(graph, lp_backup, n_edge, want_integral);
+		} else {
+			isl_basic_set_free(lp_backup);
+		}
+		return sol;
+	}
+/* ======================= AKG influence patch -- end ======================= */
 	return non_neg_lexmin(graph, lp, n_edge, want_integral);
 }
 
@@ -6002,6 +6106,11 @@
 	int use_coincidence;
 	int force_coincidence = 0;
 	int check_conditional;
+	int coincidence_relaxed=0;
+/* ====================== AKG influence patch -- start ====================== */
+	const int akg_influence = isl_options_get_akg_influence_scheduler(ctx);
+	const int akg_debug = isl_options_get_akg_print_debug(ctx);
+/* ======================= AKG influence patch -- end ======================= */
 
 	if (sort_sccs(graph) < 0)
 		return isl_stat_error;
@@ -6013,6 +6122,13 @@
 	if (ctx->opt->schedule_outer_coincidence)
 		force_coincidence = 1;
 
+	if (akg_influence) {
+		int previous_coincidence = has_coincidence;
+		int isl_maxvar = isl_influence_maxvar(graph);
+		if(graph->maxvar > isl_maxvar)
+			graph->maxvar = isl_maxvar;
+	}
+
 	use_coincidence = has_coincidence;
 	while (graph->n_row < graph->maxvar) {
 		isl_vec *sol;
@@ -6025,19 +6141,28 @@
 		if (setup_lp(ctx, graph, use_coincidence) < 0)
 			return isl_stat_error;
 		sol = solve_lp(ctx, graph);
+		if (akg_influence && sol->size)
+			graph = isl_influence_sol_add_elem(sol,graph);
 		if (!sol)
 			return isl_stat_error;
 		if (sol->size == 0) {
+			/* ====================== AKG influence patch -- start ====================== */
+			if (akg_influence && akg_debug >= 1) {
+				fprintf(stderr, "No solution!\n");
+			}
+			/* ======================= AKG influence patch -- end ======================= */
 			int empty = graph->n_total_row == graph->band_start;
 
 			isl_vec_free(sol);
 			if (use_coincidence && (!force_coincidence || !empty)) {
 				use_coincidence = 0;
+				coincidence_relaxed = 1;
 				continue;
 			}
 			return isl_stat_ok;
 		}
 		coincident = !has_coincidence || use_coincidence;
+
 		if (update_schedule(graph, sol, coincident) < 0)
 			return isl_stat_error;
 
@@ -7699,6 +7824,10 @@
 
 	if (graph->scc <= 1 || isl_options_get_schedule_whole_component(ctx))
 		return compute_schedule_wcc_whole(node, graph);
+/* ====================== AKG influence patch -- start ====================== */
+	else if (isl_options_get_akg_influence_scheduler(ctx))
+		return compute_schedule_wcc_whole(node, graph);
+/* ======================= AKG influence patch -- end ======================= */
 	else
 		return compute_schedule_wcc_clustering(node, graph);
 }
@@ -7786,7 +7915,10 @@
 			return isl_schedule_node_free(node);
 	}
 
-	if (graph->scc > 1)
+/* ====================== AKG influence patch -- start ====================== */
+	const int akg_influence = isl_options_get_akg_influence_scheduler(ctx);
+	if (graph->scc > 1 && akg_influence == 0)
+/* ======================= AKG influence patch -- end ======================= */
 		return compute_component_schedule(node, graph, 1);
 
 	return compute_schedule_wcc(node, graph);
@@ -7863,0 +7996,693 @@
+
+/* ====================== AKG influence patch -- start ====================== */
+
+int  isl_sched_node_par_coef_offset(struct isl_sched_node *node) {
+	return node_par_coef_offset(node);
+}
+
+int isl_sched_node_cst_coef_offset(struct isl_sched_node *node) {
+	return node_cst_coef_offset(node);
+}
+
+__isl_give isl_map *isl_sched_node_extract_schedule(struct isl_sched_node *node) {
+	return node_extract_schedule(node);
+}
+
+int isl_sched_node_get_nparam(const struct isl_sched_node *node) {
+	return node->nparam;
+}
+
+int isl_sched_node_get_nvar(const struct isl_sched_node *node) {
+	return node->nvar;
+}
+
+int isl_influence_int_eq(isl_vec* v, int pos1, int pos2) {
+	return isl_int_eq(v->el[pos1],v->el[pos2]);
+}
+
+isl_val* isl_influence_vec_get_elem(isl_vec* v, int pos) {
+	return isl_vec_get_element_val(v,pos);
+}
+
+isl_stat isl_sched_graph_init(struct isl_sched_graph *graph,
+	__isl_keep isl_schedule_constraints *sc) {
+	return graph_init(graph, sc);
+}
+
+void isl_sched_graph_free(isl_ctx *ctx, struct isl_sched_graph *graph) {
+	graph_free(ctx, graph);
+}
+
+__isl_give isl_schedule_node *isl_schedule_node_compute_schedule(isl_schedule_node *node,
+	struct isl_sched_graph *graph) {
+	return compute_schedule(node, graph);
+}
+
+struct isl_sched_node* isl_sched_graph_get_node(struct isl_sched_graph *graph, int i) {
+	return &graph->node[i];
+}
+
+int isl_inf_vec_get_size(isl_vec* vec) {
+	return(int) vec->size;
+}
+
+#ifdef ISL_INFLUENCE_DEBUG
+	#define isl_influence_log(format, ...) \
+	do { \
+		fprintf(stderr, (format), __VA_ARGS__); \
+	} while (0)
+#else
+	#define isl_influence_log(format, ...) \
+	do { \
+		(void) format; \
+	} while (0)
+#endif
+
+#define ISL_INFLUENCE_BLOCK_SIZE 8
+
+struct isl_sched_graph *isl_influence_sol_list_free(isl_sched_graph *graph) {
+	isl_influence_log("Entering isl_influence_sol_list_free\n");
+
+	isl_influence_sol_list *inf = graph->inf_sol_list;
+	if (inf) {
+		isl_influence_log("inf-mem: %d\n", inf->mem);
+		for (int i = 0; i < inf->mem; i++) {
+			isl_influence_sol *p = &inf->data[i];
+			p->mem = 0;
+			p->size = 0;
+			free(p->data);
+			p->data = NULL;
+		}
+		free(inf->data);
+		inf->data = NULL;
+		inf->size = 0;
+		inf->mem = 0;
+		free(inf);
+	}
+	graph->inf_sol_list = NULL;
+	isl_influence_log("Leaving isl_influence_sol_list_free\n");
+	return graph;
+}
+
+struct isl_sched_graph *isl_influence_sol_add_elem(isl_vec *sol, struct isl_sched_graph *graph) {
+	isl_influence_log("Entering isl_influence_sol_add_elem\n");
+
+	if (!sol) {
+		return graph;
+	}
+
+	isl_influence_sol_list *inf = graph->inf_sol_list;
+	if (!inf) {
+		inf = (isl_influence_sol_list *)calloc(1, sizeof(isl_influence_sol_list));
+		if (!inf) {
+			isl_influence_log("MEM ERROR: isl_influence_sol_add_elem could not allocate memory for isl_influence_sol_list\n");
+			return graph;
+		}
+		inf->mem = 0;
+		inf->size = 0;
+		inf->data = NULL;
+	}
+
+	if (inf->mem == 0) {
+		inf->mem = ISL_INFLUENCE_BLOCK_SIZE;
+		inf->data = (isl_influence_sol *)calloc(inf->mem, sizeof(isl_influence_sol));
+		if (inf->data == NULL) {
+			isl_influence_log("MEM ERROR: isl_influence_sol_add_elem could not allocate memory for isl_influence_sol_list\n");
+			return graph;
+		}
+	}
+
+	if (inf->mem == inf->size) {
+		inf->mem += ISL_INFLUENCE_BLOCK_SIZE;
+		inf->data = (isl_influence_sol *)realloc(inf->data, inf->mem * sizeof(isl_influence_sol));
+		if (inf->data == NULL) {
+			isl_influence_log("MEM ERROR: isl_influence_sol_add_elem could not reallocate memory isl_influence_sol\n");
+			return graph;
+		}
+	}
+
+	isl_influence_sol *p = &inf->data[inf->size];
+	const int sol_size = isl_inf_vec_get_size(sol);
+	p->data = (int *)calloc((size_t)sol_size, sizeof(int));
+
+	if (p->data == NULL) {
+		isl_influence_log("MEM ERROR: isl_influence_sol_add_elem could not allocate memory\n");
+		return graph;
+	}
+
+	p->mem = sol_size;
+	isl_ctx *ctx = isl_vec_get_ctx(sol);
+
+	for (int i = 0; i < p->mem; i++) {
+		isl_printer *printer = isl_printer_to_str(ctx);
+		isl_val *const val = isl_influence_vec_get_elem(sol, i);
+
+		printer = isl_printer_print_val(printer, val);
+		char *const str = isl_printer_get_str(printer);
+
+		const int value = atoi(isl_printer_get_str(printer));
+		p->data[i] = value;
+		p->size++;
+
+		free(str);
+		isl_printer_free(printer);
+		isl_val_free(val);
+	}
+
+	inf->size++;
+
+	isl_influence_log("inf->mem: %d\n", inf->mem);
+	isl_influence_log("inf->size: %d\n", inf->size);
+	isl_influence_log("Leaving isl_influence_sol_add_elem\n");
+
+	graph->inf_sol_list = inf;
+	return graph;
+}
+
+int isl_influence_sol_get_elem(int dim, int pos, struct isl_sched_graph *graph) {
+	isl_influence_sol_list *inf = graph->inf_sol_list;
+
+	if (NULL == inf) {
+		return -1;
+	}
+
+	isl_influence_sol *p = NULL;
+	int retval;
+
+	if (dim < inf->size) {
+		p = &inf->data[dim];
+	} else {
+		isl_influence_log(
+			"ERROR: isl_influence_sol_get_elem index out of range isl_influence_sol_list size : %d < dim: %d\n",
+			inf->size, dim);
+		retval = -1;
+	}
+
+	if (1 + pos < p->size) {
+		retval = p->data[1 + pos];
+	} else {
+		isl_influence_log(
+			"ERROR: isl_influence_sol_get_elem index out of range isl_ifnluence_sol size: %d < pos: %d\n",
+			p->size, pos);
+		retval = -1;
+	}
+
+	return retval;
+}
+
+void print_basic_set(isl_basic_set *set, const char *str) {
+	isl_ctx *const ctx = isl_basic_set_get_ctx(set);
+	const int print_debug = isl_options_get_akg_print_debug(ctx);
+	if (print_debug) {
+		isl_printer *printer = isl_printer_to_str(ctx);
+		printer = isl_printer_print_basic_set(printer, set);
+		char *const printed_str = isl_printer_get_str(printer);
+		isl_influence_log("%s\n", str);
+		isl_influence_log("%s\n", printed_str);
+		isl_printer_free(printer);
+		free(printed_str);
+	}
+}
+
+void *isl_influence_equal_list_free(isl_influence_equal_list *inf_equal_list) {
+	if (inf_equal_list->data) {
+		for (int i = 0; i < inf_equal_list->size; ++i) {
+			free(inf_equal_list->data[i].statement1);
+			free(inf_equal_list->data[i].statement2);
+		}
+		free(inf_equal_list->data);
+		inf_equal_list->data = NULL;
+		inf_equal_list->mem = 0;
+		inf_equal_list->size = 0;
+	}
+	free(inf_equal_list);
+	return NULL;
+}
+
+void *isl_influence_list_free(isl_influence_list *inf_list) {
+	if (inf_list->data) {
+		for (int i = 0; i < inf_list->size; ++i) {
+			free(inf_list->data[i].statement_name);
+		}
+		free(inf_list->data);
+		inf_list->data = NULL;
+		inf_list->mem = 0;
+		inf_list->size = 0;
+	}
+	free(inf_list);
+	return NULL;
+}
+
+isl_basic_set *hack_coefficients(isl_basic_set *coef, const char *msg, int pos, int lb, int ub) {
+	isl_ctx *const ctx = isl_basic_set_get_ctx(coef);
+	isl_val *const v_ub = isl_val_int_from_si(ctx, ub);
+	isl_val *const v_lb = isl_val_int_from_si(ctx, lb);
+
+	isl_size dim = isl_basic_set_n_dim(coef);
+	isl_influence_log("pos: %d\n", pos);
+	if (pos < (int)dim) {
+		const int influence_schedule = isl_options_get_akg_influence_scheduler(ctx);
+		if (influence_schedule) {
+			coef = isl_basic_set_upper_bound_val(coef, isl_dim_set, pos, isl_val_copy(v_ub));
+			coef = isl_basic_set_lower_bound_val(coef, isl_dim_set, pos, isl_val_copy(v_lb));
+			isl_influence_log(" -> i%d = (%d, %d)\n", pos, lb, ub);
+		}
+	}
+	isl_val_free(v_ub);
+	isl_val_free(v_lb);
+	return coef;
+}
+
+isl_basic_set *create_constraint(isl_basic_set *coef, const char *msg, int pos1, int pos2) {
+	isl_ctx *ctx = isl_basic_set_get_ctx(coef);
+	const int influence_schedule = isl_options_get_akg_influence_scheduler(ctx);
+	if (influence_schedule) {
+		isl_local_space *ls = isl_basic_set_get_local_space(coef);
+		isl_constraint *c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
+		c = isl_constraint_set_coefficient_si(c, isl_dim_set, pos1, 1);
+		c = isl_constraint_set_coefficient_si(c, isl_dim_set, pos2, -1);
+		coef = isl_basic_set_add_constraint(coef, c);
+		print_basic_set(coef, msg);
+
+		isl_influence_log("--> i%d = i%d\n", pos1, pos2);
+		isl_local_space_free(ls);
+	}
+
+	return coef;
+}
+
+isl_basic_set *graph_find_basic_set_by_statement_name(struct isl_sched_graph *graph, const char *name,
+	int *node_index) {
+	isl_basic_set *bset = NULL;
+	for (int i = 0; i < graph->n && bset == NULL; ++i) {
+		struct isl_sched_node *node = isl_sched_graph_get_node(graph, i);
+		isl_map *ma = isl_sched_node_extract_schedule(node);
+		const char *strstat = isl_map_get_tuple_name(ma, isl_dim_in);
+		if (strcmp(strstat, name) == 0) {
+			bset = graph->lp;
+			*node_index = i;
+		}
+		isl_map_free(ma);
+	}
+	return bset;
+}
+
+int get_pos_from_bset(isl_basic_set *bset, struct isl_sched_node *node, isl_influence_equal *inf, int coef_dim) {
+	int pos = -1;
+
+	switch (inf->type) {
+		case isl_cst:
+			pos = isl_sched_node_cst_coef_offset(node);
+			break;
+		case isl_param:
+			pos = isl_sched_node_par_coef_offset(node) - coef_dim;
+			break;
+		case isl_var:
+			pos = isl_sched_node_par_coef_offset(node) - isl_sched_node_get_nparam(node) - coef_dim * 2 - 1;
+			break;
+		default:
+			break;
+	}
+	isl_influence_log("coefficient position for coef_dim=%d: %d\n", coef_dim, pos);
+	return pos;
+}
+
+void print_influence(isl_influence_equal_list *equal, isl_influence_list *coef) {
+	isl_influence_log("Start printing isl_influence hard constraints\n");
+	for (int i = 0; coef && i < coef->size; i++) {
+		isl_influence *inf = &coef->data[i];
+		isl_influence_log("hard constraint\t\t[%d:%d]\n", i + 1, coef->size);
+		isl_influence_log("statement:\t\t%s\n", inf->statement_name);
+		isl_influence_log("type:\t\t%s\n", inf_types_str[(int) inf->type]);
+		isl_influence_log("sched_dim:\t\t%d\n", inf->sched_dim);
+		isl_influence_log("coef_dim:\t\t%d\n", inf->coef_dim);
+		isl_influence_log("val:\t\t%d\n", inf->val);
+	}
+	isl_influence_log("End printing isl_influence hard constraints\n");
+
+	isl_influence_log("Start printing isl_influence soft constraints\n");
+	for (int i = 0; equal && i < equal->size; i++) {
+		isl_influence_equal *inf_equal = &equal->data[i];
+		isl_influence_log("soft constraint\t\t[%d:%d]\n", i + 1, equal->size);
+		isl_influence_log("statement1:\t\t%s\n", inf_equal->statement1);
+		isl_influence_log("statement2:\t\t%s\n", inf_equal->statement2);
+		isl_influence_log("sched_dim1:\t\t%d\n", inf_equal->sched_dim1);
+		isl_influence_log("sched_dim2:\t\t%d\n", inf_equal->sched_dim2);
+		isl_influence_log("type:\t\t%s\n", inf_types_str[(int) inf_equal->type]);
+		isl_influence_log("coef_dim1:\t\t%d\n", inf_equal->coef_dim1);
+		isl_influence_log("coef_dim2:\t\t%d\n", inf_equal->coef_dim2);
+	}
+	isl_influence_log("End  printing isl_influence soft constraints\n");
+}
+
+int report_influence(isl_influence_equal_list *equal, isl_influence_list *coef, isl_influence_sol_list *sol,
+	int maxvar) {
+	int bad_equal = 0;
+	int bad_coef = 0;
+	int result = 1;
+	for (int i = 0; i < coef->size; i++) {
+		isl_influence *inf = &coef->data[i];
+		if (inf->scanned != 1) {
+			isl_influence_log("warning: influence hard constraint [%d] was not processed\n", i);
+			isl_influence_log("statement:\t\t%s\n", inf->statement_name);
+			isl_influence_log("type:\t\t\t%s\n", inf_types_str[(int) inf->type]);
+			isl_influence_log("sched_dim:\t\t%d\n", inf->sched_dim);
+			isl_influence_log("coef_dim:\t\t%d\n", inf->coef_dim);
+			isl_influence_log("val:\t\t%d\n", inf->val);
+			bad_coef++;
+			result = 0;
+		}
+	}
+
+	for (int i = 0; i < equal->size; i++) {
+		isl_influence_equal *inf_equal = &equal->data[i];
+		if (inf_equal->scanned != 1) {
+			isl_influence_log("warning: influence soft constraint [%d] was not processed\n", i);
+			isl_influence_log("statement1:\t\t%s\n", inf_equal->statement1);
+			isl_influence_log("statement2:\t\t%s\n", inf_equal->statement2);
+			isl_influence_log("type:\t\t\t%s\n", inf_types_str[(int) inf_equal->type]);
+			isl_influence_log("sched_dim1:\t\t%d\n", inf_equal->sched_dim1);
+			isl_influence_log("sched_dim2:\t\t%d\n", inf_equal->sched_dim2);
+			isl_influence_log("coef_dim1:\t\t%d\n", inf_equal->coef_dim1);
+			isl_influence_log("coef_dim2:\t\t%d\n", inf_equal->coef_dim2);
+			bad_equal++;
+			result = 0;
+		}
+	}
+
+	if (bad_coef == 0)
+		isl_influence_log("%d influence hard coef constraints correctly processed\n", coef->size);
+	else
+		isl_influence_log("%d influence hard coef constraints were not processed\n", bad_coef);
+
+	if (bad_equal == 0)
+		isl_influence_log("%d influence equal constraints correctly processed\n", equal->size);
+	else
+		isl_influence_log("%d influence equal constraints were not processed\n", bad_equal);
+
+	if (!sol || sol->size != maxvar) {
+		isl_influence_log("isl influence could not find solution for all dimensions");
+		result = 0;
+	}
+
+	return result;
+}
+
+int set_params(isl_influence_equal *inf, int *sched_from, int *sched_to, int *coef_from, int *coef_to, int actual_dim) {
+	int retval = 0;
+
+	if (actual_dim == 0 && inf->sched_dim1 != inf->sched_dim2) {
+		return retval;
+	} else if (actual_dim == inf->sched_dim1) {
+		if (inf->sched_dim1 >= inf->sched_dim2) {
+			*sched_from = inf->sched_dim2;
+			*sched_to = inf->sched_dim1;
+			*coef_from = inf->coef_dim2;
+			*coef_to = inf->coef_dim1;
+			retval = 1;
+		} else {
+			isl_influence_log("cannot set future coef for dimension: %d and inf_equal:\n", actual_dim);
+			isl_influence_log("inf->sched_dim1: %d\n", inf->sched_dim1);
+			isl_influence_log("inf->sched_dim2: %d\n", inf->sched_dim2);
+		}
+	} else if (actual_dim == inf->sched_dim2) {
+		if (inf->sched_dim2 >= inf->sched_dim1) {
+			*sched_from = inf->sched_dim1;
+			*sched_to = inf->sched_dim2;
+			*coef_from = inf->coef_dim1;
+			*coef_to = inf->coef_dim2;
+			retval = 1;
+		} else {
+			isl_influence_log("cannot set fuuture coef for dimension: %d and inf_equal:\n", actual_dim);
+			isl_influence_log("inf->sched_dim1: %d\n", inf->sched_dim1);
+			isl_influence_log("inf->sched_dim2: %d\n", inf->sched_dim2);
+		}
+	}
+	return retval;
+}
+
+isl_basic_set *isl_influence_set_equal(isl_ctx *ctx, struct isl_sched_graph *graph, isl_basic_set *bset) {
+	// loop over iinfluence list equal
+	isl_influence_log("Enter isl_influence_set_equal for dimension --> %d\n", graph->n_row);
+	isl_influence_equal_list *inf_list = graph->inf_equal_list;
+	for (int i = 0; i < inf_list->size; i++) {
+		isl_influence_equal *inf_equal = &inf_list->data[i];
+
+		if (inf_equal->sched_dim1 > inf_equal->sched_dim2) {
+			isl_influence_log(
+				"Error: isl cannot compute soft constraint [%d] from dimension %d to dimension %d\n",
+				i, inf_equal->sched_dim2, inf_equal->sched_dim1);
+			isl_influence_log("Reason: destination coefficient unknown\n");
+		}
+		int sched_from;
+		int sched_to;
+		int coef_from;
+		int coef_to;
+		if (!set_params(inf_equal, &sched_from, &sched_to, &coef_from, &coef_to, graph->n_row)) continue;
+
+		isl_basic_set *bset_from;
+		isl_basic_set *bset_to;
+
+		int node_index_from = -1;
+		int node_index_to = -1;
+
+		bset_from = graph_find_basic_set_by_statement_name(graph, inf_equal->statement1, &node_index_from);
+		bset_to = graph_find_basic_set_by_statement_name(graph, inf_equal->statement2, &node_index_to);
+
+		if (bset_from != NULL && bset_to != NULL && node_index_from != -1 && node_index_to != -1) {
+			int pos_from;
+			int pos_to;
+			isl_influence_log("scanning equal constraint for influence equal constraint[%d:%d]\n", i + 1, inf_list->size);
+			isl_influence_log("statement from:\t%s\n", inf_equal->statement2);
+			isl_influence_log("statement to:\t%s\n", inf_equal->statement1);
+			isl_influence_log("sched_dim from:\t%d\n", sched_from);
+			isl_influence_log("sched_dim to:\t%d\n", sched_to);
+			isl_influence_log("coef_dim from:\t%d\n", coef_from);
+			isl_influence_log("coef_dim to:\t%d\n", coef_to);
+			isl_influence_log("type:\t%s\n", inf_types_str[(int) inf_equal->type]);
+			isl_influence_log("isl_influence_set_equal: copying coef from %s to %s\n", inf_equal->statement2, inf_equal->statement1);
+
+			print_basic_set(bset_from, "bset from:");
+			print_basic_set(bset_to, "bset to:");
+			isl_influence_log("node from:\t%d\n", node_index_from);
+			isl_influence_log("node to:\t%d\n", node_index_to);
+			pos_from = get_pos_from_bset(bset_from, isl_sched_graph_get_node(graph, node_index_from), inf_equal, coef_from);
+			pos_to = get_pos_from_bset(bset_to, isl_sched_graph_get_node(graph, node_index_to), inf_equal, coef_to);
+
+			if (inf_equal->sched_dim2 == inf_equal->sched_dim1) {
+				bset = create_constraint(bset, "constraint created", pos_from, pos_to);
+				if (inf_equal->type == isl_var) bset = create_constraint(bset, "constraint created", pos_from - 1, pos_to - 1);
+			} else {
+				int val = isl_influence_sol_get_elem(sched_from, pos_from, graph);
+				isl_influence_log("val=%d\n", val);
+				bset = hack_coefficients(bset, "isl_equal", pos_to, val, val);
+				if (inf_equal->type == isl_var) {
+					val = isl_influence_sol_get_elem(sched_from, pos_from - 1, graph);
+					bset = hack_coefficients(bset, "is_equal", pos_to - 1, val, val);
+				}
+			}
+			inf_equal->scanned = 1;
+		}
+	}
+	isl_influence_log("Leave isl_influence_set_equal\n");
+	return bset;
+}
+
+__isl_give isl_schedule *akg_isl_schedule_constraints_compute_schedule_influence(
+	__isl_take isl_schedule_constraints *sc, isl_influence_list *inf_coef, isl_influence_equal_list *inf_equal) {
+	isl_ctx *ctx = isl_schedule_constraints_get_ctx(sc);
+	struct isl_sched_graph graph = {0};
+	isl_schedule *sched;
+	isl_schedule_node *node;
+
+	isl_union_set *domain;
+	isl_size n;
+
+	isl_influence_log("isl_schedule_constraints_compute_schedule : start printing constraints\n");
+	isl_printer *p;
+	p = isl_printer_to_str(ctx);
+	p = isl_printer_set_yaml_style(p, ISL_YAML_STYLE_BLOCK);
+	p = isl_printer_print_schedule_constraints(p, sc);
+	char *log_string = isl_printer_get_str(p);
+
+	isl_influence_log("%s\n", log_string);
+
+	isl_printer_free(p);
+	free(log_string);
+
+	isl_influence_log("isl_schedule_constraints_compute_schedule : end printing constraints\n");
+
+	print_influence(inf_equal, inf_coef);
+
+	graph.inf_list = inf_coef;
+	graph.inf_equal_list = inf_equal;
+
+	sc = isl_schedule_constraints_align_params(sc);
+
+	domain = isl_schedule_constraints_get_domain(sc);
+	n = isl_union_set_n_set(domain);
+	if (n == 0) {
+		isl_schedule_constraints_free(sc);
+		return isl_schedule_from_domain(domain);
+	}
+
+	if (n < 0 || isl_sched_graph_init(&graph, sc) < 0) {
+		domain = isl_union_set_free(domain);
+	}
+
+	node = isl_schedule_node_from_domain(domain);
+	node = isl_schedule_node_child(node, 0);
+
+	if (graph.n > 0) {
+		node = isl_schedule_node_compute_schedule(node, &graph);
+	}
+	sched = isl_schedule_node_get_schedule(node);
+	int result = report_influence(inf_equal, inf_coef, graph.inf_sol_list, graph.maxvar);
+
+	isl_schedule_node_free(node);
+	isl_sched_graph_free(ctx, &graph);
+	isl_schedule_constraints_free(sc);
+
+	if (!result) {
+		isl_influence_log("isl_influence failed, will fallback to default isl\n");
+		isl_schedule_free(sched);
+		sched = NULL;
+	}
+	return sched;
+}
+
+isl_basic_set *isl_influence_set_coef(isl_ctx *ctx, struct isl_sched_graph *graph, isl_basic_set *bset) {
+	isl_influence_log("Enter isl_influence_set_coef for dimension --> %d\n", graph->n_row);
+
+	isl_influence_list *inf_list = graph->inf_list;
+	int dimension = graph->n_row;
+
+	for (int i = 0; i < graph->n; ++i) {
+		struct isl_sched_node *node = isl_sched_graph_get_node(graph, i);
+		isl_map *ma = isl_sched_node_extract_schedule(node);
+		isl_influence_log("statement:\n");
+		if (ma != NULL) {
+			isl_printer *p;
+			p = isl_printer_to_str(ctx);
+			p = isl_printer_print_map(p, ma);
+
+			char *log_str = isl_printer_get_str(p);
+			isl_influence_log("%s\n", log_str);
+
+			isl_printer_free(p);
+			free(log_str);
+		}
+		isl_influence_log("end statement\n");
+		const char *strstat = isl_map_get_tuple_name(ma, isl_dim_in);
+		isl_map_free(ma);
+
+		for (int j = 0; j < inf_list->size; j++) {
+			isl_influence *inf = &inf_list->data[j];
+			if (inf->sched_dim == dimension && strcmp(strstat, inf->statement_name) == 0) {
+				int pos;
+				int ub = inf->val;
+				int lb = inf->val;
+				isl_influence_log("scanning isl coefficients for influence[%d:%d]:\n", j + 1,inf_list->size);
+
+				// S_0,S_1,...,S_n-1,S_n
+				isl_influence_log("statement_name:\t\t%s\n", inf->statement_name);
+				// i,j,k.... (only apply for type=isl_var_plus | isl_var_minus
+				isl_influence_log("sched_dim:\t\t%d\n", inf->sched_dim);
+				// coefficient index
+				isl_influence_log("rank variable:\t\t%d\n", inf->coef_dim);
+				int nparam = isl_sched_node_get_nparam(node);
+				int nvar = isl_sched_node_get_nvar(node);
+				isl_influence_log("statement variables:\t%d\n", nvar);
+				// coefficient value
+				isl_influence_log("coefficient value:\t%d\n", inf->val);
+				isl_influence_log("type:\t\t%s\n", inf_types_str[(int)(inf->type)]);
+				print_basic_set(bset, "lp  problem to influence:");
+				switch (inf->type) {
+					case isl_cst:
+						pos = isl_sched_node_cst_coef_offset(node);
+						bset = hack_coefficients(bset, "isl_cst", pos, ub, lb);
+						inf->scanned = 1;
+						break;
+					case isl_param:
+						isl_influence_log("Statement param (node->nparam): %d\n", nparam);
+						pos = isl_sched_node_cst_coef_offset(node) - (nparam - inf->coef_dim);
+						bset = hack_coefficients(bset, "isl_param", pos, ub, lb);
+						inf->scanned = 1;
+						break;
+					case isl_var:
+						// dim_+ coefficient	;
+						if (inf->coef_dim <= nvar) {
+							pos = isl_sched_node_cst_coef_offset(node) - nparam - 1 - inf->coef_dim * 2;
+							if (inf->val > 0) {
+								bset = hack_coefficients(bset, "isl_var_+", pos, ub, lb);
+								// dim_- coeffiecient
+								pos--;
+								bset = hack_coefficients(bset, "isl_var_-", pos, 0, 0);
+								inf->scanned = 1;
+							} else if (inf->val == 0) {
+								// dim_+ coefficient
+								bset = hack_coefficients(bset, "isl_var_+", pos, 0, 0);
+								// dim_- coeffiecient
+								pos--;
+								bset = hack_coefficients(bset, "isl_var_-", pos, 0, 0);
+								inf->scanned = 1;
+							} else if (inf->val < 0) {
+								bset = hack_coefficients(bset, "isl_var_+", pos, 0, 0);
+								// dim_- coeffiecient
+								pos--;
+								bset = hack_coefficients(bset, "isl_var_-", pos, -ub, -lb);
+								inf->scanned = 1;
+							} else {
+								isl_influence_log("invalid inf->val: %d\n", inf->val);
+							}
+						} else {
+							isl_influence_log("Warning: dimension overflow --> dimension required: %d max dimensions: %d\n", inf->coef_dim, nvar);
+						}
+						break;
+					default:
+					  isl_influence_log("unknown influence coef type\n");
+					  break;
+				}
+				print_basic_set(bset, "lp influenced problem:");
+    		}
+		}
+	}
+	isl_influence_log("Leave isl_influence_set_coef\n");
+	return bset;
+}
+
+int isl_influence_maxvar(struct isl_sched_graph *graph) {
+	isl_influence_log("Entering isl_influence_maxvar\n");
+	int maxvar = 0;
+	int previous = maxvar;
+	int var;
+	isl_influence_list *inf_list = graph->inf_list;
+	isl_influence_equal_list *inf_equal_list = graph->inf_equal_list;
+
+	for (int i = 0; NULL != inf_list && i < inf_list->size; i++) {
+		isl_influence *inf = &inf_list->data[i];
+		var = inf->sched_dim + 1;
+		if (maxvar < var) {
+			maxvar = var;
+		}
+	}
+	for (int i = 0; NULL != inf_equal_list && i < inf_equal_list->size; i++) {
+		isl_influence_equal *inf_equal = &inf_equal_list->data[i];
+		var = inf_equal->sched_dim1 + 1;
+
+		if (maxvar < var) {
+			maxvar = var;
+		}
+
+		var = inf_equal->sched_dim2 + 1;
+
+		if (maxvar < var) {
+			maxvar = var;
+		}
+	}
+
+	isl_influence_log("isl_influence_maxvar: %d (previous maxvar: %d)\n", maxvar, previous);
+	isl_influence_log("Leaving isl_influence_maxvar\n");
+	return maxvar;
+}
+/* ======================= AKG influence patch -- end ======================= */

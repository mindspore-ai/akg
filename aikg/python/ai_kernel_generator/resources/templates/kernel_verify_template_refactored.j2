import os
import json
import numpy as np
import signal
import functools
from typing import Union, Literal, List, Tuple, Any

# Framework imports (generated by FrameworkAdapter)
{% for line in framework_imports %}
{{ line }}
{% endfor %}
{% for line in framework_model_import %}
{{ line }}
{% endfor %}
TensorType = {{ tensor_type_name }}

{% if framework == "mindspore" %}
MS_TO_NP_DTYPE_MAP = {
    ms.float32: np.float32,
    ms.float16: np.float16,
    ms.bfloat16: np_dtype.bfloat16,
    ms.int8: np.int8,
    ms.int16: np.int16,
    ms.int32: np.int32,
    ms.int64: np.int64,
    ms.uint8: np.uint8,
    ms.uint16: np.uint16,
    ms.uint32: np.uint32,
    ms.uint64: np.uint64,
    ms.bool_: np.bool_,
}
{% endif %}

# DSL imports (generated by DSLAdapter)
{% for line in dsl_imports %}
{{ line }}
{% endfor %}
{% for line in dsl_impl_import %}
{{ line }}
{% endfor %}

# Special setup code (e.g., tilelang cache clear)
{% for line in special_setup_code %}
{{ line }}
{% endfor %}

# Binary I/O functions (only for SWFT)
{% if needs_binary_io %}
{% for line in binary_io_functions %}
{{ line }}
{% endfor %}
{% endif %}

# Timeout装饰器函数
def timeout_handler(signum, frame):
    raise TimeoutError("计算超时")

def with_timeout(timeout_seconds):
    """装饰器：为函数添加超时控制"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 设置信号处理器
            old_handler = signal.signal(signal.SIGALRM, timeout_handler)
            signal.alarm(timeout_seconds)
            try:
                result = func(*args, **kwargs)
                return result
            finally:
                # 恢复原来的信号处理器
                signal.alarm(0)
                signal.signal(signal.SIGALRM, old_handler)
        return wrapper
    return decorator

def get_limit(data_type):
    """Get precision limit for data type (generated by FrameworkAdapter)"""
    {% if framework == "torch" %}
    import torch
    if data_type == torch.float16:
        return 0.004
    elif data_type == torch.bfloat16:
        return 0.03
    elif data_type == torch.int8:
        return 0.01
    else:
        return 0.02
    {% elif framework == "numpy" %}
    import numpy as np
    if data_type == np.float16:
        return 0.004
    elif data_type == np.int8:
        return 0.01
    else:
        return 0.004
    {% elif framework == "mindspore" %}
    import mindspore as ms
    if data_type == ms.float16:
        return 0.004
    elif data_type == ms.bfloat16:
        return 0.03
    elif data_type == ms.int8:
        return 0.01
    else:
        return 0.004
    {% endif %}

def compare(framework_out_flatten, impl_out_flatten, limit, data_type):
    """Compare framework output and implementation output"""
    size = len(framework_out_flatten)
    
    # 1. 检查形状一致性
    if framework_out_flatten.shape != impl_out_flatten.shape:
        raise AssertionError(f"验证失败，输出形状不一致: framework={framework_out_flatten.shape}, impl={impl_out_flatten.shape}")
    
    # 2. 检查NaN值
    framework_nan_count = np.sum(np.isnan(framework_out_flatten))
    impl_nan_count = np.sum(np.isnan(impl_out_flatten))
    
    if framework_nan_count > 0 or impl_nan_count > 0:
        raise AssertionError(f"验证失败，检测到NaN值: Framework={framework_nan_count}/{size}, Implementation={impl_nan_count}/{size}")
    
    # 3. 检查Inf值 - 只有当两边Inf位置和符号都匹配时才允许
    framework_inf_mask = np.isinf(framework_out_flatten)
    impl_inf_mask = np.isinf(impl_out_flatten)
    
    # 检查Inf位置是否匹配
    if not np.array_equal(framework_inf_mask, impl_inf_mask):
        fw_inf_count = np.sum(framework_inf_mask)
        impl_inf_count = np.sum(impl_inf_mask)
        raise AssertionError(f"验证失败，Inf位置不匹配: Framework={fw_inf_count}/{size}, Implementation={impl_inf_count}/{size}")
    
    # 检查Inf符号是否匹配
    if np.sum(framework_inf_mask) > 0:
        inf_sign_match = np.array_equal(
            np.sign(framework_out_flatten[framework_inf_mask]), 
            np.sign(impl_out_flatten[impl_inf_mask])
        )
        if not inf_sign_match:
            raise AssertionError(f"验证失败，Inf符号不匹配")
    
    # 4. 对有限值进行精度比较
    finite_mask = np.isfinite(framework_out_flatten) & np.isfinite(impl_out_flatten)
    finite_count = np.sum(finite_mask)
    
    if finite_count == 0:
        print(f"警告: 所有值都是Inf，跳过精度检查")
        return
    
    # 提取有限值
    framework_finite = framework_out_flatten[finite_mask]
    impl_finite = impl_out_flatten[finite_mask]
    
    # 检查是否为布尔类型
    if framework_finite.dtype == bool or impl_finite.dtype == bool:
        if not np.array_equal(framework_finite, impl_finite):
            raise AssertionError(f"验证失败，布尔值不匹配: dtype={data_type}")
        return
    
    # 计算相对误差
    abs_diff = np.abs(framework_finite - impl_finite)
    abs_ref = np.abs(framework_finite)
    eps = 1e-8
    relative_error = np.where(abs_ref > eps, abs_diff / abs_ref, abs_diff)
    
    # 统计错误
    err_cnt = np.sum(relative_error > limit).astype(np.int32)
    limit_cnt = int(finite_count * limit)
    
    if err_cnt > limit_cnt:
        max_error = np.max(relative_error)
        mean_error = np.mean(relative_error)
        
        # 找出不一致的位置
        mismatch_mask = relative_error > limit
        mismatch_indices = np.where(mismatch_mask)[0]
        # 最多打印10个不一致的位置
        num_to_show = min(10, len(mismatch_indices))

        error_msg = f"验证失败，输出不一致: err_cnt={err_cnt} / {limit_cnt}, dtype={data_type}, limit={limit}\n"
        error_msg += f"最大相对误差: {max_error:.6e}, 平均相对误差: {mean_error:.6e}\n"
        error_msg += f"前 {num_to_show} 个不一致的值:\n"
        for i in range(num_to_show):
            idx = mismatch_indices[i]
            error_msg += f"  位置[{idx}]: framework={framework_out_flatten[idx]:.6e}, "
            error_msg += f"impl={impl_out_flatten[idx]:.6e}, "
            error_msg += f"相对误差={relative_error[idx]:.6e}\n"
        
        raise AssertionError(error_msg)

def verify_implementations():
    """验证框架实现和具体实现的结果一致性"""
    # 获取运行模式
    backend = "{{ backend }}"  # 计算设备后端
    arch = "{{ arch }}"  # 硬件架构
    dsl = "{{ dsl }}"  # 实现方式
    
    # 设备设置 (generated by FrameworkAdapter)
{% for line in device_setup_code %}
    {{ line }}
{% endfor %}
    
    # 输入处理函数 (generated by FrameworkAdapter)
{% for line in process_input_code %}
    {{ line }}
{% endfor %}

    def verify_single_case(inputs_for_framework, inputs_for_impl):
        """验证单个案例的公共逻辑"""
        
        
        # 设置随机种子 (generated by FrameworkAdapter)
        {% for line in set_seed_code %}
        {{ line }}
        {% endfor %}

        # 运行实现 (generated by DSLAdapter)
        {% for line in call_impl_code %}
        {{ line }}
        {% endfor %}

        # 运行原始实现
        framework_output = framework_model(*inputs_for_framework)

        if not isinstance(framework_output, (list, tuple)):
            framework_output = [framework_output]
        if not isinstance(impl_output, (list, tuple)):
            impl_output = [impl_output]
        
        # 基本检查
        if len(framework_output) != len(impl_output):
            raise AssertionError(f"验证失败，输出数量不一致: framework={len(framework_output)}, impl={len(impl_output)}")
        
        for i, (fw_out, impl_out) in enumerate(zip(framework_output, impl_output)):
            # 检查None值
            if fw_out is None or impl_out is None:
                raise AssertionError(f"输出{i}为None: framework={fw_out is None}, impl={impl_out is None}")
            
            data_type = framework_output[i].dtype
            limit = get_limit(data_type)
            
            # 转换为numpy数组 (generated by FrameworkAdapter)
            {% if framework == "torch" %}
            framework_out_flatten = fw_out.flatten().detach().cpu().numpy()
            impl_out_flatten = impl_out.flatten()
            if isinstance(impl_out_flatten, torch.Tensor):
                impl_out_flatten = impl_out_flatten.detach().cpu().numpy()
            {% elif framework == "numpy" %}
            framework_out_flatten = fw_out.flatten()
            impl_out_flatten = impl_out.flatten()
            {% elif framework == "mindspore" %}
            framework_out_flatten = fw_out.flatten().asnumpy()
            impl_out_flatten = impl_out.flatten()
            if isinstance(impl_out_flatten, ms.Tensor):
                impl_out_flatten = impl_out_flatten.asnumpy()
            {% endif %}
            
            # 统一数据类型
            if framework_out_flatten.dtype != impl_out_flatten.dtype:
                impl_out_flatten = impl_out_flatten.astype(framework_out_flatten.dtype)
            
            # 执行比对
            compare(framework_out_flatten, impl_out_flatten, limit, data_type)
        
        return True, framework_output

    def verify_with_timeout(inputs_for_framework, inputs_for_impl, timeout_msg=None, success_msg=None):
        """带超时控制的验证函数"""
        @with_timeout({{ timeout }})
        def verify_case():
            return verify_single_case(inputs_for_framework, inputs_for_impl)
        
        try:
            verify_result, framework_output = verify_case()
            if success_msg:
                print(success_msg)
            return verify_result, framework_output
        except TimeoutError:
            error_msg = timeout_msg or f"验证超时（{{timeout}}秒）"
            raise AssertionError(error_msg)

    # 获取初始化参数和输入数据
    init_params = get_init_inputs()
    framework_model = FrameworkModel(*init_params)
    
    {% if framework == "torch" %}
    framework_model = framework_model.to(device)
    {% endif %}
    
    {% if is_dynamic_shape %}
    # 动态shape：获取多组输入数据
    # 设置随机种子以确保数据可复现（先准备impl输入）
    {% for line in set_seed_code %}
    {{ line }}
    {% endfor %}
    impl_inputs_list = get_inputs_dyn_list()
    
    # 再次设置随机种子，重新生成framework输入（确保与impl一致）
    {% for line in set_seed_code %}
    {{ line }}
    {% endfor %}
    framework_inputs_list = get_inputs_dyn_list()
    
    # 对每组输入进行验证
    for case_idx, (inputs_for_impl, inputs_for_framework) in enumerate(zip(impl_inputs_list, framework_inputs_list)):
        {% if framework == "torch" %}
        inputs_for_impl = [process_input(x) for x in inputs_for_impl]
        inputs_for_framework = [process_input(x) for x in inputs_for_framework]
        {% endif %}
        
        print(f"验证动态shape案例 {case_idx + 1}/{len(framework_inputs_list)}")
        
        # 使用带超时控制的验证函数
        verify_with_timeout(
            inputs_for_framework, 
            inputs_for_impl,
            timeout_msg=f"动态shape案例 {case_idx + 1} 验证超时（{{timeout}}秒）",
            success_msg=f"动态shape案例 {case_idx + 1} 验证成功"
        )
    
    {% else %}
    # 静态shape：获取单组输入数据
    # 设置随机种子以确保数据可复现（先准备impl输入）
    {% for line in set_seed_code %}
    {{ line }}
    {% endfor %}
    inputs_for_impl = get_inputs()
    {% if framework == "torch" %}
    inputs_for_impl = [process_input(x) for x in inputs_for_impl]
    {% endif %}
    
    # 重新生成输入数据用于framework（避免原地操作影响）
    {% for line in set_seed_code %}
    {{ line }}
    {% endfor %}
    inputs_for_framework = get_inputs()
    {% if framework == "torch" %}
    inputs_for_framework = [process_input(x) for x in inputs_for_framework]
    {% endif %}
    
    # 使用带超时控制的验证函数
    verify_result, framework_output = verify_with_timeout(
        inputs_for_framework,
        inputs_for_impl,
        timeout_msg=f"静态shape验证超时（{{timeout}}秒）"
    )
    {% endif %}
    
    # 构建验证成功信息
    import time
    import uuid
    
    # 生成唯一标识符，避免并发时的日志混乱
    verification_id = str(uuid.uuid4())[:8]
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    
    # 收集验证的基础信息
    verification_info = {
        "verification_id": verification_id,
        "timestamp": timestamp,
        "op_name": "{{ op_name }}",
        "framework": "{{ framework }}",
        "backend": "{{ backend }}",
        "arch": "{{ arch }}",
        "dsl": "{{ dsl }}",
        "device_id": {{ device_id }},
        "status": "成功"
    }
    
    # 收集验证信息
    {% if is_dynamic_shape %}
    verification_info.update({
        "shape_type": "dynamic",
        "case_count": len(framework_inputs_list)
    })
    shape_info = f"形状类型: 动态 | 验证案例数: {len(framework_inputs_list)}"
    {% else %}
    output_shapes = [str(out.shape) if hasattr(out, 'shape') else str(type(out)) for out in framework_output]
    output_dtypes = [str(out.dtype) if hasattr(out, 'dtype') else str(type(out)) for out in framework_output]
    verification_info.update({
        "shape_type": "static",
        "output_count": len(output_shapes),
        "output_shapes": output_shapes,
        "output_dtypes": output_dtypes
    })
    shape_info = f"形状类型: 静态 | 输出数量: {len(output_shapes)} | 形状: {output_shapes} | 数据类型: {output_dtypes}"
    {% endif %}
    
    # 格式化输出，确保并发时不会混乱
    verification_log = f"""[{verification_id}] 验证结果: 成功
[{verification_id}] 算子: {{ op_name }} | 框架: {{ framework }} | 后端: {{ backend }} | 架构: {{ arch }}
[{verification_id}] DSL: {{ dsl }} | 设备ID: {{ device_id }} | 时间: {timestamp}
[{verification_id}] {shape_info}
[{verification_id}] {'='*60}\n\n"""
    
    print(verification_log)


if __name__ == "__main__":
    verify_implementations()


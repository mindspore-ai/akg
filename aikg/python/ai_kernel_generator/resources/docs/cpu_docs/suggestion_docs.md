# CPU C++ 专家技巧与优化建议

本文档提供 CPU C++ 开发的技巧、性能优化和问题排查指南。

## 1. 性能优化

### 数据类型选择策略
- **优先支持**: float32, float64, int32, int64
- **自动转换**: 不支持的类型自动转换为float32
- **类型检查**: 使用`scalar_type()`检查张量类型
- **指针获取**: 使用对应的`data_ptr<T>()`方法

### 循环优化策略
- **循环展开**: 手动展开循环减少分支开销
- **缓存友好**: 按行优先顺序访问数据
- **边界处理**: 向量化处理大部分数据，标量处理剩余元素
- **避免分支**: 减少条件判断，提高执行效率

### 内存访问优化
- **连续性检查**: 确保张量内存布局连续
- **数据局部性**: 尽量访问相邻内存位置
- **避免拷贝**: 减少不必要的张量拷贝操作
- **就地操作**: 尽可能进行就地修改

## 2. 数值稳定性技巧

### 防溢出处理
```cpp
// 归一化前先减去最大值
float max_val = *std::max_element(x_ptr, x_ptr + numel);
for (int64_t i = 0; i < numel; ++i) {
    float stable_data = x_ptr[i] - max_val;
    out_ptr[i] = std::exp(stable_data);
}
```
### 精度提升
- **中间计算**: 计算时精度没必要提升到double，使用float类型就可以
- **累加操作**: 使用Kahan求和算法防止精度丢失
- **避免数值下溢**: 检查除零和开方操作
- **类型转换**: 谨慎处理不同精度间的转换

## 3. 编程约束与最佳实践

### 必须遵循的规则
- **边界检查**: 所有数组访问前必须检查边界
- **类型安全**: 确保指针类型与张量类型匹配
- **异常安全**: 使用RAII管理资源
- **数据类型支持**: 优先支持常用类型，其他类型自动转换

### 内核设计原则
- **单一职责**: 每个函数只做一件事
- **参数简单**: 避免复杂的数据结构传递
- **内存局部性**: 尽量访问相邻内存位置
- **避免动态分配**: 内核内避免new/delete

## 4. 调试与排查清单

### 内存访问问题
- [ ] 所有数组访问是否都有边界检查？
- [ ] 张量是否连续？
- [ ] 指针类型是否匹配张量类型？
- [ ] 是否有越界访问？

### 类型处理问题  
- [ ] 数据类型检查是否正确？
- [ ] 类型转换是否安全？
- [ ] 输出类型是否与输入一致？
- [ ] 是否处理了所有支持的类型？

### 性能问题
- [ ] 是否使用了循环展开？
- [ ] 内存访问是否连续？
- [ ] 是否避免了不必要的拷贝？
- [ ] 是否进行了适当的优化？

## 5. 常见错误速查

| 错误类型 | 问题 | 解决方案 |
|---------|------|---------|
| 越界访问 | 段错误或结果异常 | 添加边界检查 |
| 类型不匹配 | 编译错误或运行时错误 | 检查指针类型 |
| 非连续访问 | 性能下降或错误结果 | 确保张量连续 |
| 内存泄漏 | 程序内存持续增长 | 避免手动内存管理 |


## 6. 开发建议

### 生成的代码请参考使用Python模块内嵌C++代码

### 代码风格
- 注意！！生成的代码不要包含任何测试代码
- 注意！！内嵌的C++代码一定写进嵌入脚本中，保证正确编译加载
- 内嵌C++代码使用三引号字符串，保持格式清晰
- 添加充分的注释说明计算逻辑
- 使用描述性的变量名和函数名
- 统一的错误处理模式